#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse

from ConfigParser import ConfigParser

import uuid

from prioretizer.grasslib.configurator import Params
from prioretizer.grasslib.grasslib import GRASS

from prioretizer.models.walking_cost import WalkingCost, RasterCost
from prioretizer.models.utils import temp_name

from prioretizer.defaults import DEFAULT_CONFIG_NAME


def parse_cost_config(config_file):
    config = ConfigParser()
    config.readfp(open(config_file))

    costs = dict()
    for name, cost in config.items('COSTS'):
        costs[name] = float(cost)

    conf = dict(
        attribute=config.get('ATTRUBUTE', 'name'),
        background=config.getfloat('BACKGROUND', 'cost'),
        costs=costs
    )

    return conf

def temp_name(name, prefix):
    name = name.replace(' ', '_')
    return 't' + prefix + name


def parse_args():
    parser = argparse.ArgumentParser(description='Rasterize vector layer using attribute.')

    parser.add_argument(
        '--config',
        dest='config',
        action='store',
        # const=DEFAULT_CONFIG_NAME,
        default=DEFAULT_CONFIG_NAME,
        help='Config file (default: %s)' % (DEFAULT_CONFIG_NAME, )
    )
    parser.add_argument(
        '--roads',
        dest='roads',
        action='store',
        required=True,
        help='Name of vector layer.'
    )
    parser.add_argument(
        '--stocks',
        dest='stocks',
        action='store',
        required=True,
        help='Name for raster layer of stock locations.'
    )
    parser.add_argument(
        '--output',
        dest='output',
        action='store',
        required=True,
        help='Name of output cost raster.'
    )
    parser.add_argument(
        '--cost_config',
        dest='cost_config',
        action='store',
        required=True,
        help='Name of config file to store description of the attribute.'
    )
    parser.add_argument(
        '--overwrite',
        dest='overwrite',
        action='store_const',
        const=True,
        default=False,
        help='Overwrite existing raster layer (True or False).'
    )
    args = parser.parse_args()

    return args

def main():
    args = parse_args()
    args = vars(args)

    roads = args['roads']
    stocks = args['stocks']
    output = args['output']
    overwrite = args['overwrite']

    cost_config = args['cost_config']
    cost_params = parse_cost_config(cost_config)

    attribute = cost_params['attribute']
    costs = cost_params['costs']
    background_cost = cost_params['background']

    config = args['config']
    config_params = Params(config)

    grass_lib = config_params.grass_lib
    grass_exec = config_params.grass_exec

    location = config_params.location
    dbase = config_params.grassdata

    grs = GRASS(
        gisexec=grass_exec,
        gisbase=grass_lib,
        grassdata=dbase,
        location=location,
        init_loc=True
    )

    prefix = uuid.uuid4().hex
    background_name = temp_name('back', prefix)

    raster_costs = []
    try:
        for attr_value, cost in costs.iteritems():
            name = temp_name(attr_value, prefix)
            grs.grass.run_command(
                'v.to.rast',
                input=roads,
                output=name,
                type='line',
                where='%s = "%s"' % (attribute, attr_value),
                use='val',
                value=1
            )
            raster_costs.append(RasterCost(name, cost))

        grs.grass.run_command(
            'r.mapcalc',
            expression="%s = %s" % (background_name, background_cost)
        )
        raster_costs.append(RasterCost(background_name, background_cost))

        # import ipdb; ipdb.set_trace()
        wc = WalkingCost(grs)
        wc.walking_cost(
            raster_costs=raster_costs, stocks=stocks, walking_cost=output,
            overwrite=overwrite
        )

    finally:
        for rc in raster_costs:
            name, _ = rc
            grs.grass.run_command('g.remove', type='rast', name=name, flags='f')


if __name__ == '__main__':
    main()

