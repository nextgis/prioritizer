#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse

from collections import namedtuple

from ConfigParser import ConfigParser

import uuid

from prioretizer.grasslib.configurator import Params
from prioretizer.grasslib.grasslib import GRASS

from prioretizer.defaults import DEFAULT_CONFIG_NAME

Wood_costs = namedtuple('WoodCost', 'label, wood_cost, d_cost, h_cost, b_cost')

class Cost_params:
    def __init__(self, config_file):
        self.config = ConfigParser()
        self.config.readfp(open(config_file))

        self.forest_type_column = self.config.get('ATTRIBUTES', 'forest_type')
        self.forest_count_column = self.config.get('ATTRIBUTES', 'forest_count')
        self.diameter_column = self.config.get('ATTRIBUTES', 'diameter')
        self.height_column = self.config.get('ATTRIBUTES', 'height')
        self.perspective_column = self.config.get('ATTRIBUTES', 'perspective')
        self.bonitet_column = self.config.get('ATTRIBUTES', 'bonitet')

        self.persp_factor = self.config.get('PERSP', 'cost')
        self.background_cost = self.config.get('BACKGROUND', 'cost')


        self.costs = [
            self.get_costs(s) for s in ['DUB', 'LIPA', 'KEDR', 'JASEN']
        ]

    def get_costs(self, section):
        label = self.config.get(section, 'class_label')
        wood_cost = self.config.getfloat(section, 'wood_cost')
        d_cost = self.config.getfloat(section, 'd_cost')
        h_cost = self.config.getfloat(section, 'h_cost')
        b_cost = self.config.getfloat(section, 'b_cost')

        return Wood_costs(label, wood_cost, d_cost, h_cost, b_cost)


def temp_name(name, prefix):
    return 't' + prefix + name


def parse_args():
    parser = argparse.ArgumentParser(description='Rasterize vector layer using attribute.')

    parser.add_argument(
        '--config',
        dest='config',
        action='store',
        default=DEFAULT_CONFIG_NAME,
        help='Config file (default: %s)' % (DEFAULT_CONFIG_NAME, )
    )
    parser.add_argument(
        '--woods',
        dest='woods',
        action='store',
        required=True,
        help='Name of vector layer.'
    )
    parser.add_argument(
        '--output',
        dest='output',
        action='store',
        required=True,
        help='Name of output cost raster.'
    )
    parser.add_argument(
        '--cost_config',
        dest='cost_config',
        action='store',
        required=True,
        help='Name of config file to store description of the attribute.'
    )
    parser.add_argument(
        '--overwrite',
        dest='overwrite',
        action='store_const',
        const=True,
        default=False,
        help='Overwrite existing raster layer (True or False).'
    )
    args = parser.parse_args()

    return args

def main():
    args = parse_args()
    args = vars(args)

    woods = args['woods']
    output = args['output']
    overwrite = args['overwrite']

    cost_config = args['cost_config']
    cost_params = Cost_params(cost_config)

    config = args['config']
    config_params = Params(config)

    grass_lib = config_params.grass_lib
    grass_exec = config_params.grass_exec

    location = config_params.location
    dbase = config_params.grassdata

    grs = GRASS(
        gisexec=grass_exec,
        gisbase=grass_lib,
        grassdata=dbase,
        location=location,
        init_loc=True
    )

    prefix = uuid.uuid4().hex
    col_name = temp_name('', prefix)
    bonitet_col_name = temp_name('bon', prefix)

    # Create column with cost, then rasterize the column.
    # It should be faster and simple then raster calculations (less rasterisation)
    try:
        grs.grass.run_command('v.db.addcolumn', map=woods, columns='%s double' % (col_name,))
        grs.grass.run_command('v.db.addcolumn', map=woods, columns='%s double' % (bonitet_col_name,))
        # Bonitet column has liters in the codes and Bonitet can be == 0 => recode it to new column:
        expression = "%s + 1" % (cost_params.bonitet_column, )
        grs.grass.run_command('v.db.update', map=woods, column=bonitet_col_name, value=expression)

        for wc in cost_params.costs:
            expression = "(%(count_col)s*%(wood_cost)s + %(bon_cost)s/%(bonitet)s + %(d_cost)s*%(diam)s + %(h_cost)s*%(h)s)*(%(persp_fact)s*%(persp)s+1)" \
                % dict(
                    count_col=cost_params.forest_count_column,
                    wood_cost=wc.wood_cost,
                    bon_cost=wc.b_cost,
                    bonitet=bonitet_col_name,
                    diam=cost_params.diameter_column,
                    d_cost=wc.d_cost,
                    h=cost_params.height_column,
                    h_cost=wc.h_cost,
                    persp=cost_params.perspective_column,
                    persp_fact=cost_params.persp_factor,
            )
            where = "%(type_col)s = \"%(label)s\"" % dict(type_col=cost_params.forest_type_column, label=wc.label)
            grs.grass.run_command('v.db.update', map=woods, column=col_name, value=expression, where=where)

        grs.grass.run_command('v.to.rast', input=woods, output=output, use='attr', attribute_column=col_name, overwrite=overwrite)
    finally:
        grs.grass.run_command('v.db.dropcolumn', map=woods, columns=col_name)
        grs.grass.run_command('v.db.dropcolumn', map=woods, columns=bonitet_col_name)

    expression = '{result} = if(isnull({result}), {background}, {result})'.format(result=output, background=cost_params.background_cost)
    print expression
    grs.grass.run_command('r.mapcalc', expression=expression, overwrite=True)

if __name__ == '__main__':
    main()

